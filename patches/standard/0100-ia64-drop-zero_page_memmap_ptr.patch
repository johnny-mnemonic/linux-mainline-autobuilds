From f54b009565643b2c8a05043142794457877665b6 Mon Sep 17 00:00:00 2001
From: Johnny Mnemonic <jm@machine-hall.org>
Date: Sat, 14 Feb 2026 16:13:45 +0100
Subject: [PATCH 100/101] ia64: drop zero_page_memmap_ptr

d49004c5f0c140bb83c87fab46dcf449cf00eb24 and/or the then required ia64
adaptation for it created an issue for HP-Sim/Ski kernels running in Ski
that prevented successful execution of userland programs:

```
[...]
[    1.194139] scsi host0: simulated SCSI host adapter
[    1.194139] scsi 0:0:0:0: Direct-Access     HP       SIMULATED DISK   0.00 PQ: 0 ANSI: 2
[    1.225399] sd 0:0:0:0: [sda] 16777216 512-byte logical blocks: (8.59 GB/8.00 GiB)
[    1.225399] sd 0:0:0:0: [sda] Write Protect is off
[    1.225399] sd 0:0:0:0: [sda] Asking for cache data failed
[    1.225399] sd 0:0:0:0: [sda] Assuming drive cache: write through
[    1.256619] sd 0:0:0:0: [sda] Attached SCSI disk
[    1.412845] check access for rdinit=/init failed: -2, ignoring
[    2.037829] EXT4-fs (sda): mounted filesystem 590ca40f-256f-4a23-927b-fff68d58bcf5 r/w with ordered data mode. Quota mode: disabled.
[    2.037829] VFS: Mounted root (ext4 filesystem) on device 8:0.
[    2.037829] VFS: Pivoted into new rootfs
[    2.037829] Freeing unused kernel memory: 768K
[    2.037829] This architecture does not have kernel memory protection.
[    2.037829] Run /init as init process
[    2.069161] Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000004
[    2.069161] ---[ end Kernel panic - not syncing: Attempted to kill init! exitcode=0x00000004 ]---
```

It seems like the current use of the struct page pointer
zero_page_memmap_ptr has a play into this issue. Turns out, we can do w/o
it and instead define ZERO_PAGE(vaddr) with the conversion used in
paging_init() in mm/[dis]contig.c directly. Keep paging_init() for now
even if it doesn't do anything any longer.

This fixes the issue mentioned above **and** keeps things working on
real machines (so far test on rx2620).

General idea from 18b7cc70dea8b4071ebf736724e99103115c5f95.
---
 arch/ia64/include/asm/pgtable.h | 3 +--
 arch/ia64/mm/contig.c           | 8 ++------
 arch/ia64/mm/discontig.c        | 7 ++-----
 arch/ia64/mm/init.c             | 3 ---
 4 files changed, 5 insertions(+), 16 deletions(-)

diff --git a/arch/ia64/include/asm/pgtable.h b/arch/ia64/include/asm/pgtable.h
index 7542a4badf06..f0906e2e88d2 100644
--- a/arch/ia64/include/asm/pgtable.h
+++ b/arch/ia64/include/asm/pgtable.h
@@ -444,8 +444,7 @@ static inline pte_t pte_swp_clear_exclusive(pte_t pte)
  * for zero-mapped memory areas etc..
  */
 extern unsigned long empty_zero_page[PAGE_SIZE/sizeof(unsigned long)];
-extern struct page *zero_page_memmap_ptr;
-#define ZERO_PAGE(vaddr) (zero_page_memmap_ptr)
+#define ZERO_PAGE(vaddr)	(virt_to_page(ia64_imva(empty_zero_page)))
 
 /* We provide our own get_unmapped_area to cope with VA holes for userland */
 #define HAVE_ARCH_UNMAPPED_AREA
diff --git a/arch/ia64/mm/contig.c b/arch/ia64/mm/contig.c
index 9a2f33fc843e..6a54557d780e 100644
--- a/arch/ia64/mm/contig.c
+++ b/arch/ia64/mm/contig.c
@@ -198,11 +198,7 @@ void __init arch_zone_limits_init(unsigned long *max_zone_pfns)
 }
 
 /*
- * Initialize the kernel's zero page.
+ * No longer needed.
  */
 
-void __init
-paging_init (void)
-{
-	zero_page_memmap_ptr = virt_to_page(ia64_imva(empty_zero_page));
-}
+void __init paging_init(void){}
diff --git a/arch/ia64/mm/discontig.c b/arch/ia64/mm/discontig.c
index 8592bf896c68..d6327a508556 100644
--- a/arch/ia64/mm/discontig.c
+++ b/arch/ia64/mm/discontig.c
@@ -595,12 +595,9 @@ void __init arch_zone_limits_init(unsigned long *max_zone_pfns)
 }
 
 /*
- * Initialize the kernel's zero page.
+ * No longer needed.
  */
-void __init paging_init(void)
-{
-	zero_page_memmap_ptr = virt_to_page(ia64_imva(empty_zero_page));
-}
+void __init paging_init(void){}
 
 /* workaround for a warning with -Wmissing-prototypes */
 pg_data_t * __init arch_alloc_nodedata(int nid);
diff --git a/arch/ia64/mm/init.c b/arch/ia64/mm/init.c
index 401bbe14ecbb..f6e8f2de2ba4 100644
--- a/arch/ia64/mm/init.c
+++ b/arch/ia64/mm/init.c
@@ -43,9 +43,6 @@ extern void ia64_tlb_init (void);
 
 unsigned long MAX_DMA_ADDRESS = PAGE_OFFSET + 0x100000000UL;
 
-struct page *zero_page_memmap_ptr;	/* map entry for zero page */
-EXPORT_SYMBOL(zero_page_memmap_ptr);
-
 void
 __ia64_sync_icache_dcache (pte_t pte)
 {
-- 
2.25.1

