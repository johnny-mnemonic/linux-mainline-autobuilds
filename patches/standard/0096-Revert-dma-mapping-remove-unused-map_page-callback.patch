From 77290a53d94c9f4791efeb818088030a697f9058 Mon Sep 17 00:00:00 2001
From: Johnny Mnemonic <jm@machine-hall.org>
Date: Sun, 7 Dec 2025 18:16:06 +0100
Subject: [PATCH 96/96] Revert "dma-mapping: remove unused map_page callback"

The ia64 arch code wasn't yet converted to use physical addresses, making
this a build regression:
```
arch/ia64/hp/common/sba_iommu.c:2074:10: error: 'const struct dma_map_ops' has no member named 'map_page'
 2074 |         .map_page               = sba_map_page,
      |          ^~~~~~~~
arch/ia64/hp/common/sba_iommu.c:2074:35: error: initialization of 'struct page * (*)(struct device *, size_t,  dma_addr_t *, enum dma_data_direction,  gfp_t)' {aka 'struct page * (*)(struct device *, long unsigned int,  long long unsigned int *, enum dma_data_direction,  unsigned int)'} from incompatible pointer type 'dma_addr_t (*)(struct device *, struct page *, long unsigned int,  size_t,  enum dma_data_direction,  long unsigned int)' {aka 'long long unsigned int (*)(struct device *, struct page *, long unsigned int,  long unsigned int,  enum dma_data_direction,  long unsigned int)'} [-Wincompatible-pointer-types]
 2074 |         .map_page               = sba_map_page,
      |                                   ^~~~~~~~~~~~
arch/ia64/hp/common/sba_iommu.c:2074:35: note: (near initialization for 'sba_dma_ops.alloc_pages_op')
arch/ia64/hp/common/sba_iommu.c:2075:10: error: 'const struct dma_map_ops' has no member named 'unmap_page'; did you mean 'unmap_phys'?
 2075 |         .unmap_page             = sba_unmap_page,
      |          ^~~~~~~~~~
      |          unmap_phys
arch/ia64/hp/common/sba_iommu.c:2075:35: error: initialization of 'void (*)(struct device *, size_t,  struct page *, dma_addr_t,  enum dma_data_direction)' {aka 'void (*)(struct device *, long unsigned int,  struct page *, long long unsigned int,  enum dma_data_direction)'} from incompatible pointer type 'void (*)(struct device *, dma_addr_t,  size_t,  enum dma_data_direction,  long unsigned int)' {aka 'void (*)(struct device *, long long unsigned int,  long unsigned int,  enum dma_data_direction,  long unsigned int)'} [-Wincompatible-pointer-types]
 2075 |         .unmap_page             = sba_unmap_page,
      |                                   ^~~~~~~~~~~~~~
arch/ia64/hp/common/sba_iommu.c:2075:35: note: (near initialization for 'sba_dma_ops.free_pages')
make[5]: *** [scripts/Makefile.build:287: arch/ia64/hp/common/sba_iommu.o] Error 1
make[4]: *** [scripts/Makefile.build:556: arch/ia64/hp/common] Error 2
```
So let's revert that until a better solution can be found.

This reverts commit 131971f67e258170c678fe572fda95f8cef88e66.
---
 include/linux/dma-map-ops.h |  7 +++++++
 kernel/dma/mapping.c        | 12 ++++++++++++
 kernel/dma/ops_helpers.c    |  8 +++++++-
 3 files changed, 26 insertions(+), 1 deletion(-)

diff --git a/include/linux/dma-map-ops.h b/include/linux/dma-map-ops.h
index 4809204c674c..2e98ecc313a3 100644
--- a/include/linux/dma-map-ops.h
+++ b/include/linux/dma-map-ops.h
@@ -31,6 +31,13 @@ struct dma_map_ops {
 			void *cpu_addr, dma_addr_t dma_addr, size_t size,
 			unsigned long attrs);
 
+	dma_addr_t (*map_page)(struct device *dev, struct page *page,
+			unsigned long offset, size_t size,
+			enum dma_data_direction dir, unsigned long attrs);
+	void (*unmap_page)(struct device *dev, dma_addr_t dma_handle,
+			size_t size, enum dma_data_direction dir,
+			unsigned long attrs);
+
 	dma_addr_t (*map_phys)(struct device *dev, phys_addr_t phys,
 			size_t size, enum dma_data_direction dir,
 			unsigned long attrs);
diff --git a/kernel/dma/mapping.c b/kernel/dma/mapping.c
index 37163eb49f9f..32a85bfdf873 100644
--- a/kernel/dma/mapping.c
+++ b/kernel/dma/mapping.c
@@ -171,6 +171,16 @@ dma_addr_t dma_map_phys(struct device *dev, phys_addr_t phys, size_t size,
 		addr = iommu_dma_map_phys(dev, phys, size, dir, attrs);
 	else if (ops->map_phys)
 		addr = ops->map_phys(dev, phys, size, dir, attrs);
+	else if (!is_mmio && ops->map_page) {
+		struct page *page = phys_to_page(phys);
+		size_t offset = offset_in_page(phys);
+
+		/*
+		 * The dma_ops API contract for ops->map_page() requires
+		 * kmappable memory.
+		 */
+		addr = ops->map_page(dev, page, offset, size, dir, attrs);
+	}
 
 	if (!is_mmio)
 		kmsan_handle_dma(phys, size, dir);
@@ -212,6 +222,8 @@ void dma_unmap_phys(struct device *dev, dma_addr_t addr, size_t size,
 		iommu_dma_unmap_phys(dev, addr, size, dir, attrs);
 	else if (ops->unmap_phys)
 		ops->unmap_phys(dev, addr, size, dir, attrs);
+	else
+		ops->unmap_page(dev, addr, size, dir, attrs);
 	trace_dma_unmap_phys(dev, addr, size, dir, attrs);
 	debug_dma_unmap_phys(dev, addr, size, dir);
 }
diff --git a/kernel/dma/ops_helpers.c b/kernel/dma/ops_helpers.c
index 20caf9cabf69..1eccbdbc99c1 100644
--- a/kernel/dma/ops_helpers.c
+++ b/kernel/dma/ops_helpers.c
@@ -76,9 +76,12 @@ struct page *dma_common_alloc_pages(struct device *dev, size_t size,
 	if (use_dma_iommu(dev))
 		*dma_handle = iommu_dma_map_phys(dev, phys, size, dir,
 						 DMA_ATTR_SKIP_CPU_SYNC);
-	else
+	else if (ops->map_phys)
 		*dma_handle = ops->map_phys(dev, phys, size, dir,
 					    DMA_ATTR_SKIP_CPU_SYNC);
+	else
+		*dma_handle = ops->map_page(dev, page, 0, size, dir,
+					    DMA_ATTR_SKIP_CPU_SYNC);
 	if (*dma_handle == DMA_MAPPING_ERROR) {
 		dma_free_contiguous(dev, page, size);
 		return NULL;
@@ -99,5 +102,8 @@ void dma_common_free_pages(struct device *dev, size_t size, struct page *page,
 	else if (ops->unmap_phys)
 		ops->unmap_phys(dev, dma_handle, size, dir,
 				DMA_ATTR_SKIP_CPU_SYNC);
+	else if (ops->unmap_page)
+		ops->unmap_page(dev, dma_handle, size, dir,
+				DMA_ATTR_SKIP_CPU_SYNC);
 	dma_free_contiguous(dev, page, size);
 }
-- 
2.25.1

